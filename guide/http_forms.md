---
layout: page
title: "Протокол HTTP и Формы"
permalink: http_forms.html
---

## Протокол HTTP
Как работает WWW (всемирная паутина, веб) в двух словах:
* браузер пользователя (клиент) отсылает на сервер запрос с адресом сайта (URL)
* сервер получает этот запрос и отдает клиенту требуемый тому контент

Иными словами, весь современный веб построен на модели клиент-серверного взаимодействия. И чтобы весь этот процесс оказался возможным, необходим универсальный язык-протокол, который будет понимать и сервер, и браузер.  Такой протокол есть, а называется он просто - HTTP.

### Как работает HTTP и зачем нам это знать
Программировать на PHP можно и без знания протокола HTTP, но есть ряд ситуаций, когда для решения определенных задач знание о том, как функционирует сервер, становится просто необходимым. Ведь PHP - это в первую очередь серверный язык программирования.

Протокол HTTP очень прост и состоит, по сути, из двух частей:
* заголовков запроса/ответа
* тела запроса/ответа

Всегда вначале идет список заголовков, затем пустая строка, а затем (если есть) тело запроса/ответа.

И клиент и сервер могут посылать друг другу заголовки и тело, но только в случае с клиентом доступные заголовки будут одни, а с сервером - другие.
Рассмотрим пошагово как будет выглядеть работа по протоколу HTTP в случае, когда пользователь хочет загрузить главную страницу социальной сети "Вконтакте".  

1.Браузер пользователя устанавливает соединение с сервером vk.com и отправляет следующий запрос:

```
GET / HTTP/1.1
Host: vk.com
```

2.Сервер принимает запрос и отправляет ответ:

```
HTTP/1.1 200 OK
Server: Apache  

<html>
<head><title>ВКонтакте</title></head>
<!-- остальной контент страницы ниже -->
```

3.Браузер принимает ответ и показывает готовую страничку

Больше всего нам интересен самый первый шаг, где браузер инициирует запрос к серверу vk.com  
Рассмотрим подробнее что тут происходит:
Самая первая строка этого запроса определяет несколько важных параметров, а именно:
* метод, которым будет запрошен контент
* адрес страницы
* версию протокола

`GET` - это метод (глагол), который мы применяем для доступа к указанной странице.   
`GET` является самым часто используемым методом, потому что он говорит серверу о том, что клиент всего лишь хочет прочитать указанный документ. Но помимо `GET` есть и другие методы, а один из них рассмотрим уже в следующем разделе.  

После метода идет указание на адрес страницы - URI (универсальный идентификатор ресурса). В нашем случае мы запрашиваем главную страницу сайта, поэтому используется просто слеш - `/`.  
Последним в этой строке идет версия протокола и почти всегда это будет `HTTP/1.1`  

После строки с указанием основных параметров всегда следует перечисление заголовков, которые передают серверу дополнительную, полезную информацию: название и версия браузера, язык, кодировка, параметры кэширования и т.д.  
Среди всех этих заголовков, которые передаются при каждом запросе, есть один обязательный и самый важный - это заголовок `Host`. Именно он определяет адрес домена, который запрашивает браузер клиента.  

Сервер, в свою очередь, получив запрос, ищет у себя сайт с доменом из заголовка `Host`, а также указанную страницу.  
Если запрошенный сайт и страница найдены, клиенту отправляется ответ:  
`HTTP/1.1 200 OK`  
Такой ответ означает, что все хорошо, документ найден и будет отправлен клиенту. 
Если говорить более обобщенно, стартовая строка ответа имеет следующую структуру:  
`HTTP/Версия Код состояния Пояснение`

Больше всего здесь интересен именно код состояния, он же код ответа сервера.  
 В этом примере код ответа - 200, что означает: сервер работает, документ найден и будет передан клиенту.  Но не всегда все идет гладко.  
 Например, запрошенный документ может отсутствовать или сервер будет перегружен, в таком случае клиент не получит контент, а код ответа будет отличным от 200.  
 * 404 - если сервер доступен, но запрошенный документ не найден
 * 503 - если сервер не может обрабатывать запросы по техническим причинам

Спецификация HTTP 1.1 определяет 40 различных кодов HTTP.  

После стартовой строки следуют заголовки, а затем тело ответа.

### Работа с заголовками в PHP

В PHP есть все возможности для взаимодействия с протоколом HTTP:
- получение тела запроса
- получение заголовков запроса
- добавление/изменение заголовков ответа
- управление телом ответа

Разберём все по порядку.

#### Получение тела запроса  

Тело запроса - это информация, которую передал браузер при запросе страницы.  
Но тело запроса присутствует только если браузер запросил страницу методом `POST`.  
Дело в том, что `POST` - это метод, специально предназначенный для отправки данных на сайт. Чаще всего метод `POST` браузер задействует, когда отправляет форму. Значит содержимое самой формы и будет телом запроса.  

В PHP-сценарии все данные отправленной формы будут доступны в специальном массиве `$_POST`. Более подробно об этом написано в следующей главе, посвященной формам.  

#### Получение заголовков запроса 

Напомним еще раз, что заголовки запроса - это метаинформация, отправленная браузером при запросе нашего сценария.  
PHP автоматически извлекает такие заголовки и помещает их в специальный массив - `$_SERVER`.  
Стоит отметить, что в этом массиве помимо заголовков есть и другая информация. Значения заголовков запроса находятся под ключами, что начинаются с `HTTP_`. Подробно всё содержимое этого массива описано в [официальной документации](https://www.php.net/manual/ru/reserved.variables.server.php).

Пример как получить предыдущую страницу, с которой перешел пользователь:  
```
print($_SERVER['HTTP_REFERER']);
```

#### Добавление/изменение заголовков ответа

В PHP сценарии можно управлять всеми заголовками ответа, которые попадут к пользователю вместе с контентом страницы. Это возможно, потому что PHP работает на стороне веб-сервера и имеет с ним очень тесную интеграцию.  
Вот примеры сценариев, когда пригодится управление заголовками ответа:
- кэширование
- переадресация пользователя
- установка cookies
- отправка файлов
- передача дополнительной информации браузеру

Как видно, заголовки ответа нужны для выполнения множества важных задач.  
Чтобы отправить или поменять абсолютно любой заголовок в PHP есть ровно одна функция: `header()`.  
Эта функция принимает имя и значение заголовка и добавляет его в список из всех заголовков, которые уйдут в браузер пользователю после окончания работы сценария.  
Например, таким способом выполняется перенаправление пользователя на другую страницу:  
```
header("Location: /index.php");
```
За переадресацию отвечает заголовок с именем `Location`, а через двоеточие ему задали значение - адрес страницы для перехода.  

**Важное замечание по использованию заголовков**  
Есть одно ограничение: заголовки нельзя отправлять, если пользователю уже отправили любой контент. Т.е., если показать что то на экране через, скажем, функцию `print()`, то после этого заголовки поменять уже не полуится. 

#### Управление телом ответа

Как менять тело ответа ты уже знаешь, потому что всё что PHP выводит на экран и есть содержимое ответа. Иными словами, вызовы функций `print`, `echo` или показ текста через шорт-теги: всё это является телом ответа, которое попадает в браузер пользователю.

## Параметры запроса

Мы привыкли, что на нашем сайте каждый PHP-сценарий отвечает за одну страницу. Посетитель сайта вбивает в адресную строку путь, который состоит из имени домена и имени php-сценария. Например, так: `http://weather-diary.ru/day.php`.  
Но как быть, если одна страница должна показывать разную информацию?  

На нашем сайте дневника наблюдений за погодой мы сделали отдельную страницу, чтобы показывать на ней информацию о погоде за один конкретный день из истории. Т.е. страница одна, но показывает разные данные, в зависимости от выбранного дня.  
Также пользователи хотят добавить в закладки адреса страниц, с нужными им днями. Получается, что имея только один сценарий сделать страницу, способную показывать дневник погоды за любой день невозможно? Вовсе нет!  

### Из чего состоит URI

URI - это уникальный идентификатор ресурса. Ресурс в нашем случае - это полный путь до страницы сайта. И вот как может выглядеть ресурс для показа погоды за конкретный день:  
`http://weather-diary.ru/day.php?date=2017-10-15`  

Разберем из чего состоит этот URI.  
Во-первых, здесь есть имя домена: `weather-diary.ru`.  
Затем идёт имя сценария: `day.php`  
А вот всё что идёт после - **это параметры запроса**.  

Параметры запроса - это как-бы дополнительные аттрибуты адреса страницы. Они отделяются от имени страницы знаком запроса. 
В примере выше параметр запроса только один: **date=2017-10-30**.  
Имя этого параметра:`date`, значение: `2017-10-15`.  
Параметров запроса может быть несколько, тогда они разделяются знаком амперсанда: `?date=2017-10-15&tscale=celsius`  

В примере выше указывается два аргумента: дата и единица измерения температуры.

### Параметры запроса как внешние переменные

Хорошо, теперь в адресе страницы используются параметры запроса, но какая нам от этого польза? А удобство соостоит в том, что если имя страницы вызывает к исполнению соответствующий php-сценарий, то параметры запроса становятся специальными внешними переменными в этом сценарии. Т.е. если в адресе присутствуют такие параметры, то их легко получить внутри кода сценария и выполнить нужные действия. Например, показать информацию погоду за конкретный день и в выбранных единицах измерения.

### Получение параметров запроса 

Если есть внешние переменные, то как их прочитать?  
Все параметры запроса находятся в специальном, ассоциативном массиве `$_GET`, а значит сценарий, вызванный с таким адресом: `day.php?date=2017-10-15&tscale=celsius` будет иметь в этом массиве два значения с ключами `date` и `scale` соответственно.  
Пример как сформировать запрос на получение данных за выбранный день: 
```
<?php
$date = $_GET['date'] ?? date('Y-m-d');
$sql = sprintf('SELECT * FROM weather WHERE day = "%s"', mysqli_real_escape_string($con, $date));
```

В примере выше в первой строчке мы получаем значение параметра `date`, а если он отсутствует, то используем текущую дату в качестве выбранного дня.  
Никогда не полагайтесь на существование параметра в массиве $_GET и делайте проверку либо функцией `isset()`, либо как в этом примере. 

### Формирование URI с параметрами запроса  

Иногда нужно совершить обратную операцию: сформировать адрес страницы, включив туда нужные параметры запроса из массива.  
Скажем, на странице погодного дневника надо поставить ссылку на следующий и предыдущий день. Нужно также сохранить выбранную единицу измерений. Т.е. необходимо сохранить текущие параметры запроса, поменять значение одного из них (день), и сформировать новую ссылку.  
Вот как это можно сделать:  
```
<?php
$params = $_GET;
$date = $params['date'] ?? date('Y-m-d');

$tomorrow = date('Y-m-d', strtotime('tomorrow', strtotime($date)));
$params['date'] = $tomorrow;

$url = basename(__FILE__) . '/?' . http_build_query($params);
print($url);

```

Здесь мы использовали две функции:
- `basename(__FILE__)` - получает имя текущего сценария
- `http_build_query()` - преобразует ассоциативный массив в строку запроса


## Формы
Формы - это часть языка HTML. Формы нужны для передачи любых данных от клиента на сервер. Чаще всего формы используются для регистрации пользователей, заполнения анкет, оформления заказа в интернет магазине и т.д.  
Отправлять можно как простую текстовую информацию, так и целые файлы.  
Большую часть времени программирования на PHP вы будете так или иначе работать с формами и данными из них.  

HTML описывает как выглядит форма: из каких полей и других элементов она состоит, но без принимающей стороны, т.е. сервера, который принимает эти данные и обрабатывает их нужным образом, создавать формы нет никакого смысла.  

PHP содержит множество удобных средств для работы с формами, что позволяет очень просто решать типичные задачи, которые часто возникают в веб-программировании:
 * регистрация и аутентификация пользователя
 * отправка комментариев на форумах и соц. сетях
 * оформление заказов

Практически любой современный сайт содержит как минимум несколько разных форм.

### Отправка формы
Рассмотрим один типичный пример - форма обратной связи. Чтобы дать посетителю сайта возможность связаться с его авторами, как правило используются формы обратной связи, где человек указывает как минимум свое имя, email для обратной связи и сам текст своего сообщения.  
Такая форма может выглядеть в HTML следующим образом:

```
<form name="feedback" method="POST" action="form.php">
<label>Ваше имя: <input type="text" name="name"></label>
<label>Ваш email: <input type="text" name="email"></label>
<label>Сообщение: <textarea name="message"></textarea></label>

<input type="submit" name="send" value="Отправить">
</form>
```

Это очень простая форма, состоящая из трех полей и одной кнопки отправки.  

Почти весь приведенный код описывает внешний вид и содержание формы, но следует обратить внимание на два атрибута тега `<form>`, которые нужны для указания на способ обработки данных:

* `method` - этот атрибут используется для определения метода HTTP, который будет использован для передачи данных на сервер. Вы уже знакомы с HTTP методом `GET`, предписывающим серверу просто вернуть определенный документ.  
Метод `POST` наоборот сообщает о намерении передать на сервер некоторую информацию, что, впрочем, не отменяет последующее получение контента.
* `action` - содержит адрес PHP скрипта, который должен обработать эту форму

После нажатия кнопки "отправить" браузер выполняет POST запрос, который содержит введенные данные, на адрес, указанный в атрибуте `action`.

### Обработка формы

После отправки формы управление передается php скрипту, который должен получить переданные данные, выполнить с ними какие-либо действия (например, сохранить в базе данных) и показать результат.  
Результатом может быть простое сообщение _"ваши данные успешно отправлены"_.  

Поэтому в первую очередь требуется научиться в сценарии получать данные из формы.  
К счастью, в PHP это очень просто - **все данные из формы находятся в глобальном ассоциативном массиве `$_POST`**.  
Этот массив всегда будет неявно присутствовать в сценарии, если он был загружен по методу `POST`.  
Каждое поле из формы будет находиться в массиве, где ключом будет значение атрибута `name`, а значением содержимое поля.  
Например, чтобы из формы всю информацию на экран, можно написать такой сценарий:

```
<?php
if (isset($_POST)) {
    print("Имя: " . $_POST['name']);
    print("<br>Email: " . $_POST['email']);4/30/2019 11:13:35 PM 
    print("<br>Сообщение: " . $_POST['message']);
}

```

Функция `isset` служит для определения существует ли переданная ей переменная. Так мы проверяем, что сценарий загружен методом `POST`, т.е. была отправлена форма.  

Как правило, после обработки формы в PHP, сценарий должен переадресовать пользователя на другую страницу, потому что если форма была отправлена через метод `POST`, то при обновлении страницы пользователем данные будут отправлены еще раз, а это в большинстве случаев нежелательное поведение.

### Отправка файлов

Помимо текстовой информации, существует возможность отправлять на сервер файлы любых типов.  
Пример формы для загрузки файла:

```
<form name="file_upload" method="POST" action="form.php" enctype="multipart/form-data">
<label>Ваш аватар: <input type="file" name="avatar"></label>
<input type="submit" name="send" value="Отправить файл">
</form>
```

Тут есть два важных отличия от первого примера:
* добавился новый атрибут `enctype` который всегда должен иметь значение `multipart/form-data`. Если его не будет, то файл просто не отправится.
* сам файл загружается при помощи поля с типом "file"

В PHP загруженный файл будет доступен в другом специальном массиве - `$_FILES`.  
```
<?php
if (isset($_FILES['avatar'])) {
    $file = $_FILES['avatar'];

    print("Загружен файл с именем " . $file['name'] . " и размером " . $file['size'] . " байт");
}
```

PHP автоматически сохраняет загруженный файл во временную директорию на сервере. Но хранить там файлы нельзя, потому что эта директория очищается, а кроме того на такой файл нельзя дать ссылку на сайте. Решение здесь только одно - переместить загруженный файл в другую папку. Перемещение файла всегда выполняют сразу после загрузки.  

Для начала надо убедиться, что в рабочей директории проекта существует папка для хранения файлов. Пусть она называется `uploads`. 

#### Перемещение загруженного файла

Ты прекрасно знаешь, что для перемещения файла нужно знать где он находится сейчас и место на диске, куда он будет переноситься.  
С текущим адресом всё крайне просто - он уже находится в массиве `$_FILES`. Новый адрес файла, в свою очередь, состоит из пути к папке и имени файла. Т.к. папка `uploads` находится там же, где и текущий сценарий, получить путь к ней можно так: `dirname(__FILE__)`.  

Вот как выглядит перемещение файла в новую папку:
```
<?php
$current_path = $_FILES['avatar']['tmp_name'];
$filename = $_FILES['avatar']['name'];
$new_path = dirname(__FILE__) . '/' . $filename;

move_uploaded_file($current_path, $new_path);
```

Функция `move_uploaded_file()` выполняет два действия:
1. Проверяет, что файл действительно загружен через форму
2. Перемещает загруженный файл по новому адресу


## Валидация формы

Валидация формы - это проверка содержимого её полей. Задача такой проверки - убедиться, что необходимые поля заполнены, а значения в них соответствуют ожидаемому формату.  
Так, например, при регистрации пользователя на сайте он должен заполнить поля с адресом электронной почты и придумать себе пароль. Оба поля обязательны к заполнению, но значение из поля email также должно быть корректным email адресом.  
Помимо текстовых значений формы валидировать можно и загружаемые файлы на их формат и размер.

### Общий подход к валидации

При выполнения валидации любой формы порядок действий будет всегда одним:
1. Сформировать массив с именами полей, обязательных к заполнению
2. Сформировать массив с правилами для валидации формата полей
3. Получить значения всех полей


<!---
какие могут быть проверки
валидация файлов
сохранение значений формы
как показывать ошибки в верстке
-->