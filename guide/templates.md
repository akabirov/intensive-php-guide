---
layout: page
title: "Шаблонизация и подключение файлов"
permalink: templates.html
---

# Подключение файлов

В PHP есть поддержка вызова одного сценария из другого. С помощью специальной конструкции языка можно вызвать сценарий из отдельного файла по его имени, также как по имени вызываются функции. Такая способность называется подключением файлов. Причём таковым файлом может являться как php-сценарий, так и любой другой текстовый файл. Например, HTML-страница.

## Зачем разделять и подключать php-сценарии

PHP-разработчики дробят весь исходный код проекта на отдельные сценарии, чтобы с ними проще было работать. Если бы пришлось писать весь код в одном файле, то такой сценарий стал бы просто необъятным и ориентироваться там стало решительно невозможно. Поэтому разделение кода на разные сценарии - это естественный способ бороться со сложностью.  
Есть и еще один положительный эффект от подобного деления. Если вынести повторяющиеся блоки кода в отдельные сценарии, то появится возможность повторно использовать один код в разных файлах и подключать его только по требованию. Хороший пример - это пользовательские функции. Очень удобно объявлять их в отдельном сценарии, а затем подключать там, где эти функции понадобятся.

## Способы подключения файлов

Для подключения файлов в PHP есть две языковых конструкции: `require` и `require_once`. Чем же они отличаются? На самом деле, отличия между ними минимальны. Оба этих ключевых слова подключают файл с указанным именем и вызывают ошибку, если данный файл не существует.  
Однако особенность работы `require_once` состоит в том, что файл будет подключен только один раз, даже если вызвать эту инструкцию несколько раз с одним именем файла.

### Примеры подключения файлов

Для начала посмотрим как просто подключить один сценарий внутри другого. Для этого воспользуемся инструкцией `require`. Предположим, у нас есть два сценария: `index.php` и `sub.php`.  
  
Содержимое файла `sub.php`:  
```
<?php
print("Привет, я содержимое из sub.php!" . PHP_EOL);
```
В файле `index.php` находится код, который подключит сценарий `sub.php`:
```
<?php
require 'sub.php';
print("А я - index.php!" . PHP_EOL);
``` 
Интересный факт: `require` можно использовать как ключевое слово, либо как функцию.  
Результат будет одним и тем же:
```
<?php
require('sub.php'); // использование как функции
print("А я - index.php!" . PHP_EOL);
``` 
**Результат работы:**  
```
Привет, я содержимое из sub.php!
А я - index.php!
```
Что произошло? Два сценария как бы склеились в один: выполнилось все содержимое `sub.php` и добавилось в начало сценария `index.php`.  

## Абсолютные и относительные пути

При подключении файла в качестве его адреса можно указывать абсолютный или относительный путь.  
__Абсолютный__ путь включает в себя полный адрес файла от корня диска.  
Пример: `/var/www/web/site/inc/sub.php`  
__Относительный__ путь содержит адрес только относительно текущей рабочей директории. Так если сценарий лежит в папке `/var/www/web/site`, то для подключения файла можно использовать такой путь: `inc/sub.php`  
Всегда предпочитай указывать относительные пути, чтобы сайт продолжал работать, если его переместят в другую папку.

### Полезные константы

В PHP есть полезные встроенные константы, которые пригодятся для использования в пути к подключаемым файла. 

`__DIR__`  - Полный путь к директории, в которой находится текущий сценарий  
`__FILE__` - Полный путь к текущему сценарию  


## Видимость переменных в подключаемых сценариях

Следует помнить, т.к. подключение файлов - это просто их склеивание в один, то и все переменные в разных сценариях тоже получают общую область видимости.  
В PHP нет системы модулей, которая существует в других языках программирования (Python, Java, ECMAScript 6). Невозможно "импортировать" только отдельные переменные или функции из подключаемого сценария.  
Из этого также следует, что если подключить один сценарий дважды, то переменные и функции из него тоже обьявятся повторно, а это может вызывать ошибку. Поэтому используй `require_once`, чтобы такого не произошло.

# Шаблонизация

Шаблонизация - это работа по интеграции готовой, статичной верстки на сайт.  
Ведя работу над сайтом, написанном на PHP, мы разрабатываем логику, которая управляет представлением.  
Логика - это php-сценарии, где происходит объявление переменных, функций, использование массивов и циклов, получение и обработка информации.  
Представление - это внешний вид сайта. Его страницы, которые содержат общие элементы оформления (шапка, меню, подвал) и некий контент (страницы, статьи и т.п).  


Имея на руках готовую верстку надо правильно её внедрить в работающий сайт, чтобы в определенных местах страниц информация выводилась динамически, под контролем php-сценариев.  

## Что такое "шаблон" и при чём тут рыба?  

Шаблон - это готовая верстка страницы или блока, которая состоит только из оформления и не содержит никакого контента (полезной информации)  
Шаблон по своей сути - это обычный PHP-сценарий, который на 90% состоит из HTML-кода и только на 10% из php-конструкций. Основная задача программиста в процессе работы на сайтом - это превратить статичные HTML-страницы в динамичные php-шаблоны, которые будут использоваться для показа итоговых страниц.  

Но если статичная верстка страниц не содержит динамического контента, то что будет на его месте до начала внедрения этих страниц? Когда дизайнер или верстальщик хотят показать как будет выглядеть страница на сайте, то вместо реального контента используется так называемая "рыба".  
Рыба – это заполнитель. Бессмысленный текст, который используется в верстке, чтобы показать как будет выглядеть страница, наполненная контентом.

## Проблемы типичного процесса вёрстки  

Когда верстальщик работает над несколькими страницами, ему приходится копировать бо́льшую часть HTML-кода между страницами, т.к. эти страницы содержат много повторяющихся элементов: подключение стилей, шапка сайта с логотипов, футер сайта, различные меню и т.п.  
В результате, когда дело доходит до правок, то при необходимости поменять что нибудь в той же шапке, это изменение нужно будет сделать во всех html-файлах, чтобы они выглядели одинаково. Конечно, такой мартышкин труд никому не понравится.  

## Общие фрагменты страниц сайта  

Взглянув на страницы практически любого сайта, можно заметить их сходство друг с другом. Ведь все страницы состоят из общих частей, которые не меняются, а также из областей с уникальным содержимым. И как было бы удобно редактировать общие блоки, вроде шапки сайта, отдельно, а затем вкладывать их во все страницы. Тогда при смене логотипа потребуется внести изменение только в одном месте, а все страницы сайта обновятся автоматически.  
Шаблонизация - это и есть деление всей верстки на независимые шаблоны и дальнейшее их подключение и вкладывание друг в друга. 

### Сбор страницы из частей 

Если поделить всю верстку сайта на отдельные, небольшие шаблоны мы получим сразу несколько преимуществ. Станет легче следить за единообразием интерфейса. Выделив представление сайта в шаблоны мы также существенно упростим php-сценарии, ведь в них останется только php-код. Можно даже доверить верстальщику редактировать непосредственно шаблоны, т.к. в них почти нет программного кода, а тот что есть очень простой.  

## Термины шаблонизации  

В разговоре о шаблонизации очень важно придерживаться определенных терминов, чтобы всегда было понимание о чём идёт речь. Договоримся использовать следующую терминологию:  

__Лейаут__ - это шаблон, который содержит HTML код, общий для всех страниц сайта. В нём могут содержаться подключение стилей, метатеги, шапка, подвал. Также лейаут содержит область для вставки уникального содержимого каждой страницы.  

__Шаблон страницы__ - это шаблон с уникальным для одной страницы HTML кодом. Например, для главной страницы там может быть список новостей. Также шаблон страницы может включать в себя __блоки__.  

__Блок__ - это шаблон очень небольшого блока страницы. Например это может быть один элемент списка новостей. Удобство блоков в том, один блок могут включать разные страницы.  

## Содержимое шаблона

Что же находится внутри шаблона? Ты уже знаешь, что шаблон почти полностью состоит из HTML-кода. Но помимо html тегов, там также лежат **данные** и **простая логика**.

### Данные в шаблоне

Шаблон показывает динамическую информацию. Прилагательное "динамическая" означает, что эти данные могут меняться и показываться в зависимости от различных условий. Сама информация, как правило, хранится в Базе Данных, а php-сценарий извлекает её от туда и передаёт на показ в шаблон.  
Но вне зависимости от источника информации, есть одно правило, которое никогда нельзя нарушать: любой шаблон (лейаут, шаблон страницы, блок) должен иметь доступ только к тем данным, которые ему явно передали.  
Такую изоляцию данных обеспечивает специальная функция-шаблонизатор, о которой пойдет речь далее. 

### Логика шаблона 

В шаблоне должна находиться только несложная логика. Иными словами, шаблоны не содержат «тяжёлого» php-кода, а только простые конструкции.  
Так, в шаблоне можно показывать переменные, использовать условия, циклы, обходить массивы, вызывать функции и подключать файлы. Всё другое запрещено. Оставшаяся бизнес-логика остается в php-сценариях, которые вызывают шаблоны и передают в них информацию. 

## Функция-шаблонизатор  

Шаблонизатор - это функция, которая подключает файл шаблона, передаёт ему данные и возвращает сгенерированный HTML.  
Именно шаблонизатор является тем клеем, что скрепляет воедино отдельные шаблоны в итоговую страницу. Работает он следующим образом: php-сценарий страницы выполяет все действия для подготовки необходимой информации. К примеру, запрашивает записи из базы данных. Эти записи в виде массива отправляются шаблонизатору вместе с именем шаблона страницы.  
Шаблонизатор подключает указанный файл шаблона и передаёт туда всю информацию. Но вместо вывода на экран содержимого этого шаблона он захватывает получившийся HTML-код и возвращает его.  
Затем сценарий вызывает шалбонизатор еще раз, но теперь с его помощью подключает общий лейаут, куда отправляется общая информация, а также содержимое страницы, полученное из предыдущего шага. Весь результат работы выводится на экран. 

## Пример использования 

Посмотрим на примере как это всё работает. Начнём с того, что определим три шаблона: лейаут, шаблон страницы и какой нибудь блок.  
Напоминаю, что в лейаут выносим общий HTML-код.  
[layout.php] 
```
<!DOCTYPE html>
<html lang="ru">
<head>
<title><?= $title; ?></title>
<link rel="stylesheet" href="css/style.css">
</head>
<body>
<header class="main-header">
<h1 class="visually-hidden">Дневник погоды</h1>
</header>
<div class="main-content">
	<main class="content"><?= $content; ?></main>
</div>
<footer class="main-footer"> 
	Дневник наблюдения за погодой. Все права защищены.
</footer>
</body>
</html>
```

Теперь очередь за шаблоном страницы:  
[main.php]  
```
<div class="content__main-col"> 
<h2 class="visually-hidden">Последние записи</h2> 
<a class="button" href="/gif/add">Добавить новую</a> 
 
<ul class="items-list"> 
	<?php foreach ($items as $item): ?> 
		<?=renderTemplate('inc/item.php', ['item' => $item]);?> 
	<?php endforeach; ?> 
</ul> 
</div>

``` 

Здесь обрати внимание, что шаблон страницы помимо интерации по массиву, для каждого его элемента вызывает функцию-шаблонизатор. Шаблонизатор получает контент из шаблона блока и показывает его внутри списка.  

А вот и шаблон блока для показа одной записи:  
[inc/item.php]
```
<li class="list-item"> 
	<div class="picture"> 
		<img src="uploads/preview_<?=$item['path'];?>"> 
	</div> 
	<h3 class="desc-title"> 
		<a href="/view?id=<?=$item['id'];?>"><?=$item['title'];?></a> 
	</h3> 
	<div class="desc-data"> 
		<span class="temp"><?=$item['temp'];?></span> 
	</div> 
</li>
```

Так выглядели три шаблона. Все они примут участие в формировании итоговой страницы. Соберёт эти шаблоны и выведет страницу на экран наш сценарий - index.php:

```
<?php 
// двумерный массив со списком записей 
$items_list = []; 
 
// HTML код главной страницы 
$page_content = renderTemplate('main.php', ['items' => $items_list]); 
 
// окончательный HTML код 
$layout_content = renderTemplate('layout.php',  
['content' => $page_content, 'title' => 'Дневник наблюдений за погодой']); 

// вывод на экран итоговой страницы 
print($layout_content);
```

# Уязвимости

Динамические веб-сайты активно работают с данными, полученными от пользователей. Т.е. по сути, почти вся информация на сайте была добавлена туда самими пользователями. Хороший пример такого сайта - это форум. Любой форум на 99.9% состоит из опубликованной там пользователями информации.  
Но каждый раз, когда пользователям предоставляются какие либо возможности, нужно быть готовыми к использованию этих возможностей не по назначению. Так, формы для публикации контента могут задействовать не для отправки безобидных текстов, но для заражения вашего сайта вредоносным кодом.

## Фильтрация данных

Любую информацию, полученную от пользователя, обязательно надо фильтровать перед выводом в шаблоне! 
Фильтрация означает применение к этой информации набора правил, которые очистят и подготовят её к публикации на сайте. Мы фильтруем информацию, чтобы недопустить появления на нашем сайте XSS-узвимости.

## XSS уязвимость

XSS - это вид уязвимости, которая свойственна веб-приложения.  
Данная атака на сайт состоит в том, что в выдаваемую страницу внедряется вредоносный JS-код. Это становится возможным из за недостаточной фильтрации данных, полученных от пользователя.

## Принцип атаки

1. На сайте есть форма для публикации сообщения
2. Через эту форму хакер вместо простого текста отправляет JS-код
3. Сообщение публикуется на странице, которая доступна всем посетителям
4. Вредоносный код выполняется для каждого посетителя этой страницы
5. Вредоносный скрипт вредит пользователям сайта. Например, крадет их куки

## Замена опасных символов

Проблема ясна. Надо обезопасить страницу, отфильтровав информацию из формы. Но как фильтровать, чтобы не потерять текст, но при это лишить хакера возможности нам навредить?  
Тут помогут HTML-мнемоники.  
**Мнемоника** — это кодовое представление символа в HTML, который начинается со знака амперсанда "&" и завершается точкой с запятой ";".  
Теги `<script>` состоят из треугольных скобок, а значит, если их заменить на мнемоники, то такой текст больше не будет трактоваться браузером как HTML-тег. Мнемоники часто используются, когда надо показать пользователю фрагмент с HTML-кодом на странице. Заглянув в исходный код такой страницы можно увидеть, что вместо кавычек и скобок в этом HTML-коде находятся мнемоники.  

Есть и другой вариант фильтрации: попросту вырезать все теги из текста. Нет тегов - нет проблемы.

## Функции фильтрации в PHP 

Перейдём к практике. В PHP-сценарии добавим вызов функции, которая для переданной строки выполнит фильтрацию и заменит все опасные символы в ней на подходящие HTML-мнемоники. 
Такая функция называется `htmlspecialchars`.  
Вот как выглядит её работа:
```
<?php
$text = "<script><script>"; // эту строку мы получили от пользователя
$safe_str = htmlspecialchars($text); // отфильтрованная, безопасная строка

print($safe_str); // узнаем, что получилось
```
Результат работы этого сценария: 
`&lt;script&gt;&lt;/script&gt;`  

Никогда не забывай использовать функцию `htmlspecialchars` при выводе информации от пользователей в шаблоне!
